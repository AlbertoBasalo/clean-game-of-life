/* eslint-disable max-lines */

import { BoardSize } from "./gol/board";

// ðŸš§ Reduce complexity
// ðŸš§ Use functional programming style
// ðŸš§ No global variables

// https://medium.com/hypersphere-codes/conways-game-of-life-in-typescript-a955aec3bd49

const GAME_SETTINGS = {
  initialSpeedLoopMs: 1000,
  maximumSpeedLoopMs: 50,
  minimumSpeedLoopMs: 200,
  deltaSpeedMs: 50,
};

const LIVING_RULES = {
  minimumNeighborsToKeepAlive: 2,
  maximumNeighborsToKeepAlive: 3,
  neededNeighborsToBorn: 3,
  alive: true,
  dead: false,
  randomLivingChance: 0.9,
  neighborDeltas: [-1, 0, 1],
};

const HELP_ELEMENTS = {
  buttonId: "#help-btn",
  modalId: "#help-msg",
};
const PAUSE_KEY = "p";
const INCREASE_KEY = "+";
const DECREASE_KEY = "-";
const RANDOM_KEY = "r";
const CLEAR_KEY = "c";
const HELP_KEY = "?";

// ðŸš§ Keep this global variable for now ðŸš§
const gameStatus = {
  isPaused: false,
  speedLoopMs: GAME_SETTINGS.initialSpeedLoopMs,
};
const mouseState = {
  current: LIVING_RULES.alive,
  isDown: false,
};

type GameBoard = boolean[][];

let gameBoard: GameBoard;

initializeGame();

function initializeGame() {
  console.log("initialization");

  const boardSize: BoardSize = {
    columnsCount: Math.floor(
      canvasContext.size.width / CANVAS_CONFIG.tileLength
    ),
    rowsCount: Math.floor(canvasContext.size.height / CANVAS_CONFIG.tileLength),
  };
  gameBoard = prepareBoard(boardSize);
  initializeCanvas(canvasContext);
  wireCanvasEventHandlers(canvasContext);
  wireDocumentEventHandlers(document);
  initializeBoard(gameBoard);
  drawBoard(canvasContext, gameBoard);
  initializeHelp(document);
  performLoop(canvasContext, boardSize, gameStatus);
}

async function performLoop(
  canvasContext: CanvasContext,
  boardSize: BoardSize,
  gameStatus: { isPaused: boolean; speedLoopMs: number }
) {
  // ðŸš§ Accessing global variables ðŸš§
  if (gameStatus.isPaused) {
    return;
  }
  const newBoard: GameBoard = drawNextGeneration(
    canvasContext,
    boardSize,
    gameBoard
  );
  gameBoard = newBoard;
  setTimeout(
    performLoop,
    gameStatus.speedLoopMs,
    canvasContext,
    boardSize,
    gameStatus,
    gameBoard
  );
}

function initializeCanvas(canvasContext: CanvasContext) {
  canvasContext.canvas.width = canvasContext.size.width;
  canvasContext.canvas.height = canvasContext.size.height;
  canvasContext.context.fillStyle = CANVAS_CONFIG.fillStyle;
  canvasContext.context.strokeStyle = CANVAS_CONFIG.strokeStyle;
  canvasContext.context.lineWidth = CANVAS_CONFIG.lineWidth;
}

function initializeBoard(gameBoard: GameBoard) {
  gameBoard[0][2] = LIVING_RULES.alive;
  gameBoard[1][0] = LIVING_RULES.alive;
  gameBoard[1][2] = LIVING_RULES.alive;
  gameBoard[2][1] = LIVING_RULES.alive;
  gameBoard[2][2] = LIVING_RULES.alive;
}

function prepareBoard(boardSize: BoardSize): GameBoard {
  const board = [];
  for (
    let columnNumber = 0;
    columnNumber < boardSize.columnsCount;
    columnNumber++
  ) {
    const row = [];
    for (let rowNumber = 0; rowNumber < boardSize.rowsCount; rowNumber++) {
      row.push(LIVING_RULES.dead);
    }
    board.push(row);
  }
  return board;
}

function drawBoard(canvasContext: CanvasContext, gameBoard: GameBoard) {
  const columnsCount: number = gameBoard.length;
  const rowsCount: number = gameBoard[0].length;
  for (let columnNumber = 0; columnNumber < columnsCount; columnNumber++) {
    for (let rowNumber = 0; rowNumber < rowsCount; rowNumber++) {
      drawCell(canvasContext.context, gameBoard, rowNumber, columnNumber);
    }
  }
}

function drawCell(
  context: CanvasRenderingContext2D,
  gameBoard: boolean[][],
  rowNumber: number,
  columnNumber: number
) {
  if (isAlive(gameBoard, columnNumber, rowNumber)) {
    context.fillRect(
      columnNumber * CANVAS_CONFIG.tileLength,
      rowNumber * CANVAS_CONFIG.tileLength,
      CANVAS_CONFIG.tileLength,
      CANVAS_CONFIG.tileLength
    );
  }
}

function redrawGameCanvas(canvasContext: CanvasContext, gameBoard: GameBoard) {
  clearCanvas(canvasContext);
  drawBoard(canvasContext, gameBoard);
}

function drawNextGeneration(
  canvasContext: CanvasContext,
  boardSize: BoardSize,
  gameBoard: GameBoard
): GameBoard {
  const nextGameBoard = calculateNextGeneration(gameBoard, boardSize);
  redrawGameCanvas(canvasContext, nextGameBoard);
  return nextGameBoard;
}

/* Canvas user interaction */

// âœ… Homogenize event handlers

function wireCanvasEventHandlers(canvasContext: CanvasContext) {
  // ðŸš§ Accessing global variable gameBoard ðŸš§
  canvasContext.canvas.addEventListener("mousedown", mouseEvent => {
    mouseState.isDown = true;
    const [columnNumber, rowNumber] = getPositionFromMouseEvent(
      mouseEvent,
      canvasContext.canvas
    );
    const stateAtMousePosition = gameBoard[columnNumber][rowNumber];
    const newToggledState = !stateAtMousePosition;
    gameBoard[columnNumber][rowNumber] = newToggledState;
    mouseState.current = newToggledState;
    redrawGameCanvas(canvasContext, gameBoard);
  });
  canvasContext.canvas.addEventListener("mousemove", mouseEvent => {
    if (mouseState.isDown) {
      const [columnNumber, rowNumber] = getPositionFromMouseEvent(
        mouseEvent,
        canvasContext.canvas
      );
      gameBoard[columnNumber][rowNumber] = mouseState.current;
      redrawGameCanvas(canvasContext, gameBoard);
    }
  });
  canvasContext.canvas.addEventListener("mouseup", () => {
    mouseState.isDown = false;
  });
}

function wireDocumentEventHandlers(document: Document) {
  document.addEventListener("keydown", keyBoardEvent => {
    const keyPressed = keyBoardEvent.key;
    const allowedKeys = Object.keys(keyActions);
    if (allowedKeys.includes(keyPressed)) {
      const action = keyActions[keyPressed];
      action();
    }
  });
}
/** Menu listeners */

const keyActions: Record<string, () => void> = {
  [PAUSE_KEY]: () => {
    gameStatus.isPaused = !gameStatus.isPaused;
  },
  [INCREASE_KEY]: () => {
    gameStatus.speedLoopMs = Math.max(
      GAME_SETTINGS.maximumSpeedLoopMs,
      gameStatus.speedLoopMs - GAME_SETTINGS.deltaSpeedMs
    );
  },
  [DECREASE_KEY]: () => {
    gameStatus.speedLoopMs = Math.min(
      GAME_SETTINGS.minimumSpeedLoopMs,
      gameStatus.speedLoopMs + GAME_SETTINGS.deltaSpeedMs
    );
  },
  [RANDOM_KEY]: () => {
    // ðŸš§ Accessing global variable gameBoard ðŸš§
    gameBoard = generateRandomGameBoard(gameBoard);
  },
  [CLEAR_KEY]: () => {
    // ðŸš§ Accessing global variable gameBoard ðŸš§
    const columnsCount: number = gameBoard.length;
    const rowsCount: number = gameBoard[0].length;
    gameBoard = prepareBoard({ columnsCount, rowsCount });
  },
};

/* Help button and modal */
function initializeHelp(document: Document) {
  const helpButton = document.querySelector(HELP_ELEMENTS.buttonId);
  const helpModal = document.querySelector(HELP_ELEMENTS.modalId);

  const toggleHelpModal = () => {
    helpModal?.classList.toggle("hidden");
  };
  helpButton?.addEventListener("click", toggleHelpModal);
  document.addEventListener("keydown", keyboardEvent => {
    if (keyboardEvent.key === HELP_KEY) {
      toggleHelpModal();
    }
  });
}
